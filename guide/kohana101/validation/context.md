# Контексты валидации

Во время выполнения [проверки](validation/check) фреймворк предоставляет возможность использовать несколько заранее определенных
 псевдонимов:

 * `:validation` - текущий объект `Validation` (устанавливается один раз, перед началом проверки)
 * `:data` - проверяемый массив данных (устанавливается один раз, перед началом проверки)
 * `:field` - имя проверяемого поля (меняется для каждого поля)
 * `:value` - значение проверяемого поля (меняется для каждого поля)

Они нужны для управления работой [правил валидации](validation/rules).

## Использование {#using}

Контексты позволяют подставлять соответствующие значения в правила валидации. Например, если нам надо передать в правило
 значение и имя поля, то получится примерно такая конструкция:

    $valid->rule('foo', 'Foo::bar', array(':field', ':value'));

Данная запись означает, что мы добавили для поля 'foo' правило, которое вызовет метод `Foo::bar()` с передачей в него
 имени поля и его значения:

    class Foo {
        public static function bar($field, $value)
        {
            // ...
        }
    }

Контексты обычно используют в собственных правилах (*callbacks*) или анонимных функциях. Например, необходимо проверить,
 совпадают ли введенные значения пароля (`password`) и его подтверждения (`password_confirm`).

Первый способ - с использованием *callback*'а:

    // в контроллере
    $valid->rule('password_confirm', array($this, 'compare_passwords'), array(':value', ':data'));

    // метод compare_passwords в этом же контроллере
    public function compare_passwords($value, array $data)
    {
        return $value == $data['password'];
    }

Все правила, кроме анонимных функций, должны просто возвращать **TRUE/FALSE**, поэтому нам достаточно просто сравнить два поля.

Второй способ - анонимная функция для проверки:

    $valid->rule('password_confirm', function($value, Validation $validation) {
        $result = $value == $validation['password'];
        if ( ! $result ) {
            $validation->error('password_confirm', 'compare_passwords');
        }
        return $result;
    }, array(':value', ':validation'));

Принцип тот же, главное различие в том, что анонимная функция должна самостоятельно регистрировать [ошибки валидации](validation/errors).
 Именно для этого в нее надо передать объект `Validation` (т.е. контекст ':validation').

[!!] Даже самые простые правила валидации используют контексты. Например, если мы явно не указали список аргументов для
 правила, то в него будет передано значение проверяемого поля через контекст ':value'.

## Добавление собственных контекстов {#custom}

Предусмотрена возможность установить свои контексты. Для этого используйте метод [Validation::bind]:

    // создаем какой-то объект класса Library, в котором содержатся нужные методы валидации
    $obj = new Library;
    $valid->bind(':lib', $obj);
    // а теперь можно использовать этот объект в своих правилах валидации
    // причем не только в качестве аргумента
    $valid->rule('password', array(':lib', 'check_strength'));

В данном примере мы используем контекст ':lib' для указания объекта, содержащего нужное нам правило.

[!!] Контекст может называться как угодно, необязательно начинаться с двоеточия. Однако, рекомендуется придерживаться одного
 стиля с разработчиками фреймворка.