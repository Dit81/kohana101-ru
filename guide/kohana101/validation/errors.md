# Ошибки валидации

## Описание {#about}

Основная задача валидации - проверить поступившие данные на наличие несоответствий установленным правилам. При этом сам
 результат проверки (т.е. **TRUE/FALSE**) не имеет особого смысла без указания собственно ошибок.

Согласно правилам проведения [проверки](validation/check), каждому полю массива может соответствовать не более одной ошибки.
 Т.е. мы получаем пару "поле" - "правило", которая позволяет однозначно определить источник ошибки (значение поля) и
 проваленный критерий проверки (правило).

Для получения списка ошибок используется метод [Validation::errors]. Будучи вызван без аргументов, он возвращает массив
 ошибок в следующем "сыром" виде:

    array(
        "поле"   => array(
            [0]=> "название правила",
            [1]=> [дополнительные параметры]
        ),
        // и т.д.
    );

Такая структура нужна для генерации красивых [сообщений об ошибках](validation/errors/i18n). Второй элемент массива
 ("дополнительные параметры") может содержать полезную информация для этих сообщений. Например, если правилом ограничена
 максимальная длина строки, то в тексте сообщения было бы неплохо указать эту самую длину. [Стандартные правила](validation/rules/valid)
 валидации отправляют в дополнительные параметры все переданные аргументы правила.

    $data = array(
        'password'         => 'qwer',
    );
    $valid = Validation::factory($data);
    // устанавливаем для пароля минимальную длину в 5 символов
    $valid->rule('password', 'min_length', array(':value', 5));
    if (! $valid->check())
    {
        echo Debug::vars($valid->errors());
    }

В результате получим такой дамп:

    array(1) (
        "password" => array(2) (
            0 => string(10) "min_length"
            1 => array(2) (
                0 => string(4) "qwer"
                1 => integer 5
            )
        )
    )

Видно, что для поля `password` сгенерирована ошибка правилом `min_length`, в качестве дополнительных параметров переданы
 значение поля и ограничение минимальной длины.

## Имена правил в ошибках {#names}

Существует несколько способов, которыми `Validation` получает имя правила для генерации ошибки:

 * Самый простой вариант, если в качестве правила указано имя стандартной функции PHP или метода класса [Valid]. Например, 'min_length'.
 Оно и будет именем правила.
 * Если передано имя статического метода вместе с классом (например, [Valid::min_length]), то из него будет извлечено
 имя метода, которое будет использовано в качестве имени правила. В нашем примере это 'min_length'.
 * Если передан callback вида `array($this, 'check_password')`, то второй параметр этого массива (название метода) будет
 использовано как имя правила.
 * Если правило - это анонимная функция, то имя правила задается внутри этой функции, вместе с собственно сохранением ошибки.

## Регистрация ошибок {#adding}

Если правило обнаружило несоответствие проверяемого значения своим критериям, оно возвращает **FALSE**, и объект `Validation`
 регистрирует ошибку валидации для поля, основываясь на имени правила. Таким образом, даже в случае реализации собственных
 правил вручную ошибки сохранять не надо.

Единственное исключение - анонимные функции. В них мы должны сохранять ошибку самостоятельно:

    $valid->rule('email', function($value, $field, $validation) {
        if (FALSE == filter_var($value, FILTER_VALIDATE_EMAIL))
        {
            // сохраняем ошибку
            $validation->error($field, 'check_mail');
            return FALSE;
        }
        return TRUE;
    }, array(':value', ':field', ':validation'));

`$validation->error($field, 'check_mail');` добавляет в объект `Validation` информацию о том, что правило 'check_mail'
 обнаружило ошибку для значения в поле `$field`. Для формирования [текста ошибки](validation/errors/i18n) может понадобиться
 проверяемое значение поля, поэтому можно слегка поправить вызов:

    `$validation->error($field, 'check_mail', array($value));`

[!!] Дополнительные параметры передаются без ключей, поэтому важно знать порядок, в котором они были добавлены.

