# Правила валидации

## Описание {#about}

Правило - это атомарная операция, выполняющая проверку поступившего значения на соответствие своим внутренним критериям.
 У каждого правила свой алгоритм, это может быть простая проверка размерности строки или отдельный запрос к базе данных
 для поиска дублирующих записей. Принципиально сложность правил ничем не ограничена.

## Добавление правил {#adding}

Синтаксис следующий:

     $valid->rule($field, $rule, $params);

 * `$field` - имя поля, т.е. под каким ключом в исходном массиве лежит проверяемое значение. Можно указать **TRUE**, т.е.
  правило будет активно для всех полей.
 * `$rule` - само правило в виде [callback](http://ru.php.net/manual/en/language.pseudo-types.php#language.types.callback) PHP.
 * `$params` - массив параметров для правила (опционально). Например, для проверки на длину строки надо передать максимально
  допустимое значение. Если не указать `$params`, то будет передаваться только проверяемое значение (в большинстве случаев
  этого достаточно).

Метод `rule()` возвращает объект `Validation`, так что можно делать цепочки вызовов:

    $valid->rule(...)
          ->rule(...)
          ->rule(...);

## Примеры добавления правил {#examples}

    $data = array(
       'string'    => 'string value',
       'integer'   => '256',
       'email'     => 'test@example.com',
    );
    $valid = Validation::factory($data);
    // начинаем добавлять правила
    // в качестве имени правила передаем строку
    $valid->rule('string', 'max_length', array(':value', 10));
    // передаем имя статического метода
    $valid->rule('integer', 'Valid::range', array(':value', 0, 100));
    // используем callback для вызова метода объекта
    $valid->rule('email', array($this, 'check_email'));

Наиболее простой вариант правила - указать его в виде строки. В таком случае будут анализироваться три варианта вызова правил:

 * Если специальный класс [Valid] содержит метод с таким именем, то будет вызван именно этот метод.
 * Если существует функция PHP, то используем ее.
 * Проверяется синтаксис вызова статического метода в виде `class::method`. Выше приведен такой вызов [Valid::range].

Возможны и более сложные правила.

### Правило в виде массива {#callback}

Можно передать массив, в таком случае первый элемент должен быть объектом (например `$this`, экземпляр какого-либо класса),
 а второй - названием его метода. Например, `array($this, 'check_email')`. В большинстве случаев такое правило необходимо
 создавать самостоятельно. Давайте рассмотрим случай, когда необходимо проверить email на корректность.

    // где-то в контроллере
    $valid->rule('email', array($this, 'check_email'));

    // метод в этом же контроллере
    public function check_email($value)
    {
        return filter_var($value, FILTER_VALIDATE_EMAIL);
    }

[!!] Не забывайте про область видимости функции, ведь private- или protected-метод не может быть вызван извне.

Метод на входе может принимать любые параметры, главное не забыть их указать при объявлении в методе `rule()`. В нашем случае
 использовался самый распространенный вариант - передача только значения.

Правило должно возвращать **TRUE**, если проверяемое значение удовлетворяет условиям, иначе - **FALSE**.

### Анонимные функции {#anonymous}

Еще один вариант - использование [анонимных функций](http://php.net/manual/ru/functions.anonymous.php) (PHP>=5.3). Ту же
 проверку email можно реализовать через замыкания:

    $valid->rule('email', function($value) {
        return filter_var($value, FILTER_VALIDATE_EMAIL);
    });

Выглядит правильно, но валидация с таким вызовом ошибки не выдаст. Дело в том, что анонимные функции обязаны самостоятельно
 регистрировать ошибки валидации (во всех остальных случаях класс `Validation` сам выполняет эту работу). В результате
 получим немного другой код:

    $valid->rule('email', function($value, $field, $validation) {
        if (FALSE == filter_var($value, FILTER_VALIDATE_EMAIL))
        {
            $validation->error($field, 'check_mail');
            return FALSE;
        }
        return TRUE;
    }, array(':value', ':field', ':validation'));

Наша анонимная функция проверяет email на корректность, и в случае ошибки сохраняет ее в объект `$validation`. Для этого мы
 должны его передать в качестве параметра. Так как при регистрации ошибки надо указать имя проверяемого поля, то дополнительно
 передается аргумент `$field`, которое это имя содержит. Не забывайте вернуть **FALSE** в случае несоответствия правилу.

Так как объявление правила должно этому правилу соответствовать, в качестве списка аргументов мы указываем
 `array(':value', ':field', ':validation')`. Это значение поля, имя поля и объект валидации (т.е. `$valid`). Строки типа
 ':value' представляют собой что-то вроде именованной ссылки (контекст), которые в дальнейшем будут заменены на
 соответствующие значения. Это позволяет нам "передавать" значения полей, объект валидации и прочие элементы, не зная
 заранее их значений. Более подробно контексты будут разобраны в соответствующем [разделе](validation/context).

[!!] Вышеописанный "велосипед" на самом деле не имеет особого смысла, т.к. проверка email на корректность имеется в виде штатного
 метода [Valid::email], и может быть легко использована как `$valid->rule('email', 'email');` или
 `$valid->rule('email', 'Valid::email');`

## Массовые добавления правил {#grouping}

Если правил для поля несколько, то можно их объявить одним вызовом:

    // отдельные вызовы
    $valid->rule('string', 'max_length', array(10))
          ->rule('string', 'not_empty');

    $valid->rules('string', array(
        // каждое правило - массив из callback + параметры (если есть)
        array('max_length', array(10)),
        array('not_empty'),
    ));

Первый аргумент общий для всех правил - это имя поля. Далее каждое правило представляет из себя массив, в котором первый
 элемент является собственно правилом (callback), а второй - параметры для его вызова.

[!!] В этих многочисленных `array()` несложно запутаться, поэтому в коде стоит выделять отдельную строчку под каждое правило.

## Копирование объекта Validation {#copying}

Можно легко создать копию объекта `Validation` со всеми настроенными правилами, но уже для другого массива данных. Для этого
 имеется метод [Validation::copy]:

    $valid = Validation::factory($_POST);
    $valid->rules('field1', array(...));
    $valid2 = $valid->copy($_GET);

Сначала мы создали объект валидации для массива `$_POST`, добавили в него правила, а затем применили эти же настройки, но
 для проверки массива `$_GET` (переменная `$valid2`). При этом старый объект `$valid` остался неизменным.