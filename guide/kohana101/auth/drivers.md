# Драйверы Auth

Сам по себе класс **Auth** описывает лишь базовые возможности. Вся внутренняя реализация зависит от используемого драйвера.
 **Kohana** предоставляет два варианта драйвера - [файловый](auth/file/basic) и [ORM](auth/orm/basic).

## Файловый драйвер {#file}

Это единственный драйвер, поставляемый вместе с модулем **Auth**. Все настройки (в том числе логин и [хеш пароля](auth/hashing)) хранятся
 в конфигурационном файле, отсюда и название. Данный драйвер имеет смысл использовать для создания систем с ограниченным
 количеством пользователей без возможности управлять пользователями.

## Драйвер ORM {#orm}

Несмотря на то, что он не входит в комплект модуля **Auth**, драйвер **ORM** является самым популярным драйвером. Он позволяет
 реализовать все основные возможности модуля:

* Аутентификация с флагом "запомнить меня"
* Роли
* Смена пароля (точнее, возможность его поменять, так как хеш хранится в БД, а не в конфигурационном файле)

[!!] Конечно, чтобы пользоваться драйвером **ORM**, необходим не только модуль **Auth**, но и модуль **ORM**.

## Написание собственного драйвера {#custom}

Модуль **Auth** позволяет создавать собственные драйверы, если по каким-то причинам существующие не устраивают. Например,
 можно найти драйвер для **Jelly ORM**, **Doctrine**, и даже **LDAP**. Все, что необходимо для написания драйвера, это наследоваться от
 базового класса [Auth] и реализовать следующие обязательные методы:

* `protected function _login($username, $password, $remember)` - тут происходит аутентификация. Метод должен извлечь
 из хранилища пароль для пользователя `$username` и сравнить его с переданным `$password`. Параметр `$remember` указывает,
 надо ли "запомнить" пользователя в случае успешной аутентификации, но реализовать такую возможность необязательно.
* `public function password($username)` - метод должен возвращать пароль пользователя `$username`.
* `public function check_password($password)` - сравнивает переданный пароль с паролем текущего пользователя.

[!!] Модуль `Auth` не принуждает к хешированию паролей, так что написанный драйвер может работать с "сырыми" паролями.
 Но все же задумайтесь, стоит ли подходить к вопросам безопасности пользовательских данных спустя рукава.