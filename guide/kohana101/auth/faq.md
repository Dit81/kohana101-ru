# FAQ

Ниже перечислены наиболее частые вопросы и проблемы, возникающие при работе с модулем **Auth**.

## Пароль из хеша {#unhashing}

**Вопрос**: Как извлечь пароль, зная хеш?

**Ответ**: Никак, и это правильно. Хеш является односторонним алгоритмом, именно поэтому он и используется при сохранении паролей.
 Срочно удаляйте учетную запись на сайте, если после регистрации вы получили свой пароль по email, либо сайт предоставляет
 возможность восстановить пароль без его смены.

## Проверка пароля {#password-check}

**Вопрос**: А как же тогда проверяется пароль?

**Ответ**: Введенный пользователем пароль передается в метод [Auth::hash], который на его основе создает хеш и сравнивает
 с хешем правильного пароля. Если они совпадают, пароль введен правильно.

## Пустые пароли {#empty-pass}

**Вопрос**: Разрешены ли пустые пароли?

**Ответ**: Конечно, в БД хеш пустой строки не будет пустой строкой. Но даже если пользователь сможет сохранить в качестве
 пароля пустую строку или NULL, модуль **Auth** не позволит войти с таким паролем.

 Единственная возможность это обойти - переопределить метод [Auth::login]:

	public function login($username, $password, $remember = FALSE)
	{
		return $this->_login($username, $password, $remember);
	}

Отличие от штатного метода `login()` в отсутствии проверки переменной `$password` функцией `empty()`.

## Коллизии {#collision}

**Вопрос**: Может ли хеш от неправильного пароля совпасть с правильным?

**Ответ**: Теоретически может. Вероятность очень небольшая, и она тем меньше, чем длиннее строка хеша (зависит от выбранной
 [функции хеширования](auth/hashing)).

## login() не работает {#failed-login}

**Вопрос**: метод `login()` возвращает **FALSE**.

**Ответ**: Последовательно проверяем по пунктам:

 * Пользователь с таким логином и паролем существует
 * У пользователя есть роль `login` (она обязательна для успешной работы метода `login()`)
 * После регистрации пользователя не менялся секретный ключ (`hash_key`) или алгоритм хеширования (`hash_method`). Изменение
  одного из этих параметров приведет к тому, что все предыдущие учетные записи не смогут быть использованными из-за несовпадения
  паролей.
 * Проверьте длину поля `password` в базе данных (если используется). Она должна быть 64 символа (или более). Если меньше,
  то сохраняемый хеш будет обрезаться, что сделает невозможным успешное сравнение хешированных паролей.

## Админ не может зайти {#admin-role}

**Вопрос**: Пользователь с ролью `admin` не может авторизоваться.

**Ответ**: С точки зрения модуля `Auth`, единственно необходимой ролью является `login`. Без нее авторизоваться не получится. Роль
 `admin` обязательной не является, и никаких свойств роли `login` не наследует.

## Редирект {#missed-login}

**Вопрос**:  Авторизация слетает после редиректа. Почему?

**Ответ**: Очевидно, проблема в сохранении пользовательского объекта в сессии. Обычно это связано с неправильной настройкой кук,
 которые по умолчанию используются как драйвер для сессии. Проверьте домен куки.

## Несколько драйверов {#mixed-drivers}

**Вопрос**: Можно ли использовать несколько драйверов одновременно?

**Ответ**: Если возникла потребность в параллельном существовании нескольких объектов **Auth**, можно попробовать создавать их вручную,
 передавая в конструктор конфигурацию:

	// этот объект будет базовым, с дефолтными настройками
	$auth = Auth::instance();
	// загружаем настройки для дополнительного Auth
	$config2 = Kohana::$config->load('another_auth');
	// создаем объект вручную
	$auth2 = new Auth($config2);

В `$config2` параметры `driver` и `session_key` должны отличаться от дефолтных, чтобы избежать возможного конфликта данных.

## Разлогинить всех {#logout-all}

**Вопрос**: Как разлогинить всех вошедших под конкретной учетной записью?

**Ответ**: "Из коробки" `Auth` таких возможностей не предоставляет. Так как данные об авторизованных пользователях модулем не сохраняются,
 закончить сессию сразу у всех не получится. Необходимо создать отдельную таблицу для хранения актуальных (обновляющихся)
 сессий пользователей и проверять ее при каждом обращении. Таким образом, удаление всех записей с определенным `user_id`
 приведет к завершению всех сессий этого пользователя.

[!!] Аналогично решается проблема функционала "кто сейчас на сайте".

## Статистика входа {#login-stats}

**Вопрос**: после каждого входа выполняется обновление профиля пользователя - увеличивается счетчик успешных входов
 (поле `logins`) и метка времени последнего входа (`last_login`). Как от этого отказаться?

**Ответ**: Необходимо переопределение метода [Model_User::complete_login]. Как вариант, можно пойти на хитрость - удалите
 поля из БД, а в модель `Model_User` добавьте свойства `logins` и  `last_login`. В результате модель будет записывать в них
 значения, но без запроса в БД (ведь оригинальные значения из БД не поменялись).

## Валидация пароля {#password-validation}

**Вопрос**: В модели `Model_User` поле `password` автоматически хэшируется при присвоении. Как же тогда осуществляется его
 проверка на минимальную длину и сравнение с полем `password_confirm`?

**Ответ**: Валидация пароля осуществляется посредством внешней валидации **ORM** (этот механизм обычно используется, чтобы
 иметь возможность проверять искуственные поля типа `password_confirm`). В методах [Model_User::create_user] и [Model_User::update_user]
 вызывается специальный метод [Model_User::get_password_validation], который создает объект `Validation` с правилами для
 проверки пароля. В нем хранятся "сырые" значения, никаких хэшей.