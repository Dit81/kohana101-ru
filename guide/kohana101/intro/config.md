# Конфигурационные файлы

При работе с **Kohana** вам доступно множество различных настроек. Большинство их них можно разместить в специальных файлах,
 называемых конфигурационными (или, сокращенно, - "конфиги"). Размещаются они в директориях `config` и разбиваются в соответствии
 с использующим их классом/модулем.

Вот пример конфига по умолчанию для модуля `Auth` (файл `MODPATH/auth/config/auth.php`):

    <?php defined('SYSPATH') or die('No direct access allowed.');

    return array(

        'driver'       => 'file',
        'hash_method'  => 'sha256',
        'hash_key'     => NULL,
        'lifetime'     => 1209600,
        'session_type' => Session::$default,
        'session_key'  => 'auth_user',

        // Username/password combinations for the Auth File driver
        'users' => array(
            // 'admin' => 'b3154acf3a344170077d11bdb5fff31532f679a1919e716a02',
        ),

    );

Структура файла простая - он должен возвращать массив с настройками. Теоретически, элементами массива могут быть данные
 любого типа: строки, числа, массивы и т.д.

## Инициализация драйверов конфигурации {#init}

Обращение к конфигурации происходит через объект `Kohana::$config` класса `Kohana_Config`. Он выступает в роли хранилища
 для отдельных драйверов конфигурации. Их можно подключить несколько, по умолчанию присутствует только стандартный файловый
 драйвер:

    Kohana::$config->attach(new Config_File);

Он будет искать конфигурационные файлы в директориях `config`. Если мы захотим обрабатывать еше конфиги из директорий `configuration`,
 то можно подключить драйверы вот так:

    // сперва подключаем дефолтный драйвер
    Kohana::$config->attach(new Config_File);
    // а теперь добавим свой драйвер
    Kohana::$config->attach(new Config_File('configuration'));

Теперь в хранилище подключены два объекта `Kohana_Config`, у каждого из которых свои настройки.

Чем позже мы добавим свой драйвер, тем выше по приоритету он будет. Если вдруг понадобится добавить драйвер так, чтобы он
 был "младшим", то передайте в качестве второго аргумента **FALSE**:

    Kohana::$config->attach(new Config_File('configuration'), FALSE);

## Работа с конфигами {#using}

Для извлечения информации используется метод [Kohana_Config::load]:

     // возвращает все настройки для модуля Database
     $db_settings = Kohana::$config->load('database');
     // возвращает только профиль "default" из настроек Database
     $db_settings = Kohana::$config->load('database')->get('default');
     // то же самое, но одним вызовом
     $db_settings = Kohana::$config->load('database.default');

[!!] Точки в имени конфигурации используются как разделители, по аналогии с [Arr::path].

`Kohana::$config->load()` возвращает два типа объектов:

 * `Kohana_Config_Group`, если запрошена группа конфигов. Например, `Kohana::$config->load('database')`
 * Простой массив, если запрашивается часть конфига. Например, `Kohana::$config->load('database.default')`

В первом случае мы запрашиваем все конфигурации с именем 'database' (в случае с драйвером `Kohana_Config_File`) это
 означает все файлы `config/database.php`. Поэтому возвращается объект, содержащий целое подмножество найденных
 конфигураций. Во втором случае мы хотим работать с конкретной частью конфига, и нам достаточно получить обычный массив.

Зачем такие сложности? Дело в том, что при работе с целыми конфигами появляется возможность вносить в них изменения и
 сохранять их. Соответственно обычных массивов недостаточно.

### Загрузка конфигов {#loading}

Каскадная файловая система Kohana позволяет нам иметь несколько конфигурационных файлов с одинаковым именем. Что будет в
 этом случае? Давайте рассмотрим следующий пример.

Имеется три конфигурационных файла:

    // SYSPATH/config/foo.php - конфиг в директории system
    return array(
        'a'     => array(
            'a1'        => 'sys',
            'a2'        => 'sys',
            'a3'        => 'sys',
        ),
    );

    // MODPATH/foo/config/foo.php - конфиг в модуле foo
    return array(
        'a'     => array(
            'a1'        => 'mod',
            'a2'        => 'mod',
        ),
    );

    // APPPATH/config/foo.php - конфиг в директории application
    return array(
        'a'     => array(
            'a1'        => 'app',
        ),
    );

Что получится, если вызвать `Kohana::$config->load('foo')`? Фреймворк найдет все три файловых конфига и дальше они будут
 объединены в один. При этом будет учитываться нахождение соответствующего источника в [КФС](intro/cascadefs). В данном
 случае наивысший вес будет иметь конфиг из директории `application`, за ним конфиг из модуля, и только за ними - конфиг
 из `system`. Выглядит это как наложение массивов. Берем массив с низким приоритетом, на него "накладываем" следующий конфиг
 и т.д. В нашем случае получится следующий конфиг:

    array(
         'a'     => array(
             'a1'        => 'app',
             'a2'        => 'mod',
             'a3'        => 'sys',
         ),
     );

Ключ 'a1' был во всех трех конфигах, но из-за наивысшего приоритета там оказалось значение 'app' (из `application`). Так
 как ключа 'a2' в `application` не было, то его значение берется из следующего по приоритету конфига, т.е. из модуля foo.
 От конфига из директории `system` осталось только значение ключа 'a3', только потому, что у остальных конфигов такого
 ключа не было.

[!!] Может получиться ситуация, что искомый конфиг найден в нескольких модулях. В таком случае больший приоритет получит
 тот модуль, что находится выше в списке [Kohana::modules], т.е. был объявлен раньше.

Стоит помнить, приоритетный конфиг полностью затирает "конкурентов". Например, конфигурационный файл из `application`
 мог выглядеть так:

    // APPPATH/config/foo.php - конфиг в директории application
    return array(
        'a'     => 'app', // не массив, а простая строка
    );

В итоге значения ключа 'a' из других конфигов мы потеряем.

### Kohana_Config_Group {#group}

Этот класс реализует интерфейс `ArrayObject`, т.е. с ним можно обращаться как с обычным массивом:

    // получили объект Kohana_Config_Group
    $db_settings = Kohana::config->load('database');
    // извлекаем профиль default, обращаясь к конфигу как к массиву
    $default = $db_settings['default'];
    // то же самое, но через метод класса
    $default = $db_settings->get('default');
    // или даже так
    $default = $db_settings->default;
    // можно редактировать настройки
    $default['hostname'] = 'localhost';
    // или через метод класса
    $default->set('hostname', 'localhost');

[!!] У каждой группы есть свое имя. Например, если мы получали конфиг 'database', то и имя группы будет 'database'. Его
 всегда можно посмотреть с помощью метода `group_name()`.

В любой момент времени можно превратить объект `Kohana_Config_Group` в обычный массив, для этого есть метод `as_array()`.

Обращаться к элементам конфига можно как через методы класса ([Kohana_Config_Group::get]/[Kohana_Config_Group::set]), так
 и через квадратные скобки.

## Заключение {#outro}

В первую очередь стоит помнить о том, что конфиги собираются по всей файловой системе **Kohana**. Поэтому рекомендуется
 копировать необходимые конфигурационные файлы из `system` и `modules` в `application` и вносить в них правки уже там.
 Изначально предполагаем, что в ядре и модулях фреймворка конфиги содержат значения по умолчанию и их просто необходимо
 актуализировать под разрабатываемое приложение (например, настройки подключения к базе данных в конфиге `database.php`).
 Иногда это стоит делать для повышения защищенности, например в случае настройки различных "секретных" фраз (модуль `Auth`).

Несмотря на то, что конфигурационный файл должен возвращать массив значений, никто не мешает в нем производить какие-то
 несложные вычисления. Например, в зависимости от степени завершения проекта могут различаться настройки подключения к БД:

    return array(
        'foo'     => (Kohana::$environment > Kohana::PRODUCTION ? 'bar' : 'baz')
    );

Если имеется необходимость сохранять измененную конфигурацию, то стандартный драйвер `Config_File` не подойдет. В модуле
 [Database](database) есть драйвер `Config_Database`, который работает через таблицу в БД.