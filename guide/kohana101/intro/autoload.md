# Автозагрузка классов

В **Kohana** нет необходимости подключать все используемые классы вручную (через `require` или `include`), так как используется
 [автоматическая загрузка классов](http://ru2.php.net/manual/ru/language.oop5.autoload.php).

## Имена классов {#classnames}

В **Kohana** все классы должны быть расположены в директории `classes`, допускается использовать поддиректории. Имя класса
 может состоять из нескольких слов, разделенных знаком подчеркивания. Каждое слово означает один уровень вложенности в директории
 `classes`, и должно иметь в верхнем регистре только первый символ. Исключения - аббревиатуры, например класс `HTTP`.

 имя файла                        | имя класса
----------------------------------|----------------------
 classes/foo.php                  | `Foo`
 classes/foo/bar.php              | `Foo_Bar`
 classes/kohana/http/header.php   | `Kohana_HTTP_Header`

## Загрузка классов {#using}

Поиск и загрузка классов происходит автоматически, не требуется предварительно подгружать какие-либо файлы классов:

    // автоматически загружает классы ORM, Kohana_ORM, Model_User и т.д.
    $user = ORM::factory('user', 1);

## Автозагрузчик {#loader}

**Kohana** предлагает свой собственный автоматический загрузчик, который по умолчанию [подключается](intro/settings#autoload) 
 в файле `bootstrap.php`:

    /**
     * Enable the Kohana auto-loader.
     *
     * @see  http://kohanaframework.org/guide/using.autoloading
     * @see  http://php.net/spl_autoload_register
     */
    spl_autoload_register(array('Kohana', 'auto_load'));

    /**
     * Enable the Kohana auto-loader for unserialization.
     *
     * @see  http://php.net/spl_autoload_call
     * @see  http://php.net/manual/var.configuration.php#unserialize-callback-func
     */
    ini_set('unserialize_callback_func', 'spl_autoload_call');

Передача `array('Kohana', 'auto_load')` в качестве имени загрузчика означает, что будет использован метод [Kohana::autoload].

Он работает очень просто. Предположим, что поступил вызов `Kohana::autoload('Kohana_ORM')`. Т.е. необходимо найти и подключить
 класс `Kohana_ORM`. Из имени класса загрузчик формирует путь к файлу: `classes/kohana/orm.php`. Далее начинается поиск
 файла с таким именем: `Kohana::find_file('classes', 'kohana/orm')`. Напомню, что поиск осуществляется с учетом возможностей
 [Каскадной Файловой Системы](intro/cascadefs).

[!!] Если файл не найден, метод возвращает `FALSE`. Таким образом, можно подключать дополнительные автозагрузчики, которые будут
 задействованы если штатный загрузчик не нашел искомый класс.

[Поиск файлов](intro/cascadefs#find-file) - достаточно затратный процесс, а структура файлов на стадии окончания разработки практически не меняется. Поэтому
 имеется возможность записывать найденные пути к классам в кэш, чтобы в следующий раз не искать в файловой системе заново.
 Используйте параметр `caching` при [инициализации](intro/settings#init) ядра фреймворка.

## Свой загрузчик {#custom}

Иногда может потребоваться подключение стороннего модуля со своими правилами именования классов. Как правило, для него
 приходится использовать отдельный загрузчик (либо написать свой). Чтобы зарегистрировать его в системе, просто добавьте
 вызов `spl_autoload_register()` в файле `bootstrap.php` (или в `init.php` модуля):

    // регистрируем загрузчик foo::autoload()
    spl_autoload_register(array('foo', 'autoload'));

Для корректной работы загрузчика необходимо, чтобы класс `foo` был доступен. Либо **Kohana** может его найти с помощью стандартного
 загрузчика (т.е. он написан по стандартам Kohana), либо файл с этим классом необходимо заранее загрузить через `include`/`require`.