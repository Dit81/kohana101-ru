# Маршрутизация

Механизм маршрутизации (т.н. `роутинг`) позволяет преобразовывать введенный пользователем адрес (`URL`) в информацию для
 выполнения запроса фреймворком. Как минимум это данные о [контроллере](intro/mvc/controller) и его экшене. Также существует
 обратная маршрутизация (`reverse routing`), которая из набора параметров маршрута составляет URL.

Маршрут (route) - это основная логическая единица маршрутизации. Каждый маршрут является набором правил, описывающих некое
 множество адресов. Например, адреса `/article/1` и `/article/2` предполагают один и тот же маршрут (ключевое слово `article`, а
 за ним идентификатор статьи).

## Объявление маршрута {#add}

В **Kohana** по умолчанию добавляется маршрут с именем 'default':

    // файл bootstrap.php
    Route::set('default', '(<controller>(/<action>(/<id>)))')
        ->defaults(array(
            'controller' => 'welcome',
            'action'     => 'index',
        ));

Первый аргумент метода `Route::set()` - имя маршрута. Второй - его `URI`, причем обычно он содержит сегменты маршрута,
 описывающие отдельные части (параметры). В данном примере это имя контроллера (сегмент `<controller>`), экшена (`<action>`)
 и дополнительный параметр `<id>`. Название сегмента оборачивается в угловые скобки.

`URI` может содержать необязательные сегменты. Они заключаются в круглые скобки. В нашем примере URI целиком состоит из
 опциональных сегментов. Причем сегменты допускается делать вложенными.

URI                       | Параметры маршрута                        | Пропущенные параметры
------------------------- | ----------------------------------------- | -------------------------
 /                        | -                                         | controller, action, id
 /welcome                 | controller=welcome                        | action, id
 /welcome/home            | controller=welcome, action=home           | id
 /article/show/1          | controller=article, action=show, id=1     | -
 /article/list            | controller=article, action=list           | id
 /article/show/1/2        | -                                         | -

[!!] Все слэши в начале и конце адреса автоматически подчистятся при создании [запроса](basic/request). Поэтому с точки
 зрения роутинга адреса `welcome`, `/welcome` и `/welcome/` равнозначны.

Последний адрес не подпадает под требования маршрута и не может быть им обработан. Дело в том, что каждый параметр по умолчанию
 может состоять только из латинских букв, цифр и знака подчеркивания. Поэтому слэш обычно является разделителем параметров.

### Стандартные параметры маршрута {#params}

В **Kohana** некоторые параметры будут присутствовать всегда, даже если они не определены в маршруте.

Название          | Описание
----------------- | ------------------------------------------------------------------
 controller       | Имя контроллера, без префикса `Controller_`. Т.е. значение `welcome` означает контроллер `Controller_Welcome`.
 action           | Имя экшена, без префикса `action_`. Например, `index` - это метод `action_index()` контроллера.
 directory        | Необязательный параметр, используйте для указания поддиректории для контроллера. Значение `admin_test` приведет к тому, что класс контроллера будет `Controller_Admin_Test_Welcome`.
 host             | Этот параметр определяет имя хоста, который будет обрабатывать запрос. Актуально для [внешних запросов](basic/request/external).

### Параметры по умолчанию {#defaults}

Если в маршруте есть необязательные параметры, то они должны иметь значения по умолчанию. Для этого необходимо их указать
 с помощью метода `defaults()`. Посмотрим на все тот же дефолтный маршрут:

        ->defaults(array(
            'controller' => 'welcome',
            'action'     => 'index',
        ));

Устанавливаются значения по умолчанию для параметров `controller` и `action`. Если параметр не указан в `defaults()`, то
 он будет равен **NULL**. Таким образом,
 адреса `/`, `welcome` и `welcome/index` будут вести на одну и ту же страницу.

[!!] Исключение из этого правила - параметр `action`, который по умолчанию установлен в 'index'.

В `defaults()` можно указать даже параметры, отсутствующие в `URI`. Например:

    Route::set('static', 'info(/<action>)')
        ->defaults(array(
            'controller' => 'static',
            'action'     => 'about',
        ));

Данный маршрут обрабатывает адреса вида `info`, `info/about` и т.д. Независимо от переданного адреса, будет использоваться
 контроллер `static`.


### Параметр directory {#directory}

Часто бывает, что один или несколько контроллеров расположены в поддиректориях относительно папки `controllers`. Наиболее
 часто вспоминаемый случай - группа контроллеров "админки", лежащие в директории `controllers/admin/`. Дефолтный маршрут
 обработает адрес `/admin/dashboard/`, но не так, как мы ожидаем. Параметр `controller` будет не `admin/dashboard`, а
 'admin'. Соответственно сегмент `dashboard` будет воспринят как экшен.

Чтобы исправить подобные ситуации, необходимо использовать параметр `directory`:

    Route::set('admin', 'admin(/<controller>(/<action>(/<id>)))')
        ->defaults(array(
            'directory'   => 'admin',
            'controller'  => 'dashboard',
        ));

[!!] По итогам анализа данного маршрута по умолчанию будет сгенерировано имя контроллера `Controller_Admin_Dashboard`, и
 ожидаемое имя файла `controllers/admin/dashboard.php`. При этом в вызове `defaults()` мы указываем имя контроллера без
 префикса `admin_`. Система сама его возьмет из параметра `directory`.

В данном примере может быть только одно значение `directory`. Никто нам не мешает сделать этот параметр динамическим:

    Route::set('directory', '<directory>(/<controller>(/<action>(/<id>)))')
        ->defaults(array(
            'controller'  => 'dashboard',
        ));

Данный пример не самый удобный, т.к. он будет перехватывать практически любой предложенный URI, в том числе и те, которые
 не используют параметр `directory`. Так как обычно количество таких поддиректорий ограничено и они заранее известны, можно
 сделать более точный маршрут:

    Route::set('directory', '<directory>(/<controller>(/<action>(/<id>)))', array('directory' => '(admin|auth|forum)'))
        ->defaults(array(
            'controller'  => 'dashboard',
        ));

В данном случае маршрут будет обрабатывать только адреса, начинающиеся с '/admin/', '/auth/' или '/forum/'.

[!!] Старайтесь делать маршруты максимально точными. Таким образом вы сможете избежать "перехватов" чужих URI.

### Параметр host {#host}

Этот параметр имеет смысл только для внешних маршрутов (см. ниже).

### Регулярные выражения {#regex}

Можно устанавливать дополнительные проверки для сегментов маршрута, например его длину или состав. Для этого при создании
 маршрута укажите третий аргумент - массив регулярных выражений для сегментов.

    // разрешаем адреса /auth/login/, /auth/logout/ и /auth/register/
    Route::set('auth', 'auth(/<action>)', array('action' => '(login|logout|register)'))
        ->defaults(array(
            'controller' => 'auth',
        ));

Другой пример - маршрут для генерации адресов как в Wordpress:

    // разрешаем адреса вида /2012/, /2012/03/, /2012/03/05/ и /2012/03/05/article-title/
    Route::set('blog', '<year>(/<month>(/<day>(/<title>)))', array(
            'year'  => '(19|20)\d{2}',             // четырехзначное число от 1900 до 2099
            'month' => '(0[1-9]|1[012])',
            'day'   => '(0[1-9]|[12][0-9]|3[01])',
            'title' => '[\d\w\-]+',
        ))
        ->defaults(array(
            'controller' => 'blog',
            'action'     => 'article',
        ));

Можно немного усложнить, добавив идентификатор статьи к заголовку:

    // разрешаем адреса вида /2012/, /2012/03/, /2012/03/05/ и /2012/03/05/123-article-title/
    Route::set('blog', '<year>(/<month>(/<day>(/<id>(-<title>))))', array(
            'year'  => '(19|20)\d{2}',
            'month' => '(0[1-9]|1[012])',
            'day'   => '(0[1-9]|[12][0-9]|3[01])',
            'title' => '[\d\w\-]+',
            'id'    => '[\d]+',
        ))
        ->defaults(array(
            'controller' => 'blog',
            'action'     => 'article',
        ));

Один из распространенных приемов - создание универсального маршрута, который будет срабатывать для любого адреса. Это бывает
 необходимо для отображения страницы-заглушки.

    Route::set('catch-all', '<uri>', array('uri' => '.*'))
        ->defaults(array(
            'controller'  => 'static',
            'action'      => 'index',
        ));

## Сложные маршруты {#complex}

TODO: расписать возможности применения лямбда-функций и callback'ов.

## Где лучше объявлять маршруты? {#places}

Логично, что маршрут должен быть объявлен где-то в начале работы приложения, чтобы принимать участие в анализе URI. Основные
 такие места - это файл `bootstrap.php` (там расположен маршрут по умолчанию), а также файлы `init.php` в директориях модулей.
 Эти файлы загружаются сразу после ядра фреймворка, поэтому и являются оптимальным местом для размещения роутинга.

## Несколько маршрутов в системе {#order}

В проекте может существовать множество различных маршрутов. Каким образом происходит выбор нужного? Все маршруты хранятся
 в стеке (свойство `Route::$_routes`) по принципу FIFO. То есть чем раньше был добавлен маршрут, тем больший приоритет перед другими он имеет.

Рассмотрим на примере стандартного файла `bootstrap.php`:

     Kohana::modules(array(
        // 'auth'       => MODPATH.'auth',       // Basic authentication
        // 'cache'      => MODPATH.'cache',      // Caching with multiple backends
        // 'codebench'  => MODPATH.'codebench',  // Benchmarking tool
         'database'   => MODPATH.'database',   // Database access
        // 'image'      => MODPATH.'image',      // Image manipulation
        // 'orm'        => MODPATH.'orm',        // Object Relationship Mapping
        // 'unittest'   => MODPATH.'unittest',   // Unit testing
         'userguide'  => MODPATH.'userguide',  // User guide and API documentation
        ));

    /**
     * Set the routes. Each route must have a minimum of a name, a URI and a set of
     * defaults for the URI.
     */
    Route::set('default', '(<controller>(/<action>(/<id>)))')
        ->defaults(array(
            'controller' => 'welcome',
            'action'     => 'index',
        ));

Дефолтный маршрут расположен в самом конце файла `bootstrap.php`, и он в итоге попадет в самый конец стека. Также в модуле
 `userguide` имеется файл `init.php`, в котором объявлено несколько маршрутов. Как мы помним, файлы `init.php` выполняются
 сразу при добавлении модуля. Таким образом, все маршруты модуля `userguide` будут добавлены раньше, чем маршрут `default`.

Если же в нескольких модулях имеются объявления маршрутов, то в этой ситуации играет важную роль очередность добавления
 модулей (метод `Kohana::modules()`). В данном примере маршруты модуля `database` будут более приоритетными, чем `userguide`.

Впрочем, маршрут может быть добавлен ДО вызова `Kohana::modules()`. В этом случае он будет самым первым в стеке.

[!!] Не стоит недооценивать важность того порядка, в котором добавлены маршруты. Особенно если имеются "универсальные"
 маршруты, вроде рассмотренного ранее `catch-all`.

## Что дальше? {#more}

 * [Работа с маршрутами](basic/routing/using)
 * [Обратная маршрутизация](basic/routing/reverse)