# Запрос

Объект `Request` - один из основных элементов ядра фреймворка. В *Kohana v3.2* он выполняет следующие задачи:

 * Подготовка запроса. Обработка исходных данных: IP клиента, заголовки браузера (User_Agent), используемый HTTP-метод
    запроса (GET/POST/PUT/DELETE), и т.д. Все эти данные передаются в созданный экземпляр класса `Request`. Таким образом,
    у каждого объекта создается свое окружение
 * [Поиск](#routing) [маршрута](basic/routing), подходящего под URI запроса
 * Запустить необходимый [контроллер](intro/mvc/controller) на выполнение
 * Получить от контроллера ответ и сохранить его в виде экземпляра класса [Response](basic/response).

По сути, объект `Request` выполняет контроль над выполнением приложения, от получения клиентских данных до генерации сервером
 ответа.

## Создание запроса {#new}

Первоначальный объект `Request` создается фреймворком автоматически. Загляните в конец файла `index.php` и вы увидите там
 следующие строки:

     echo Request::factory()
        ->execute()
        ->send_headers()
        ->body();

Сейчас нас интересует первая строчка, т.е. метод [Request::factory]. Он может принимать дополнительные параметры:

 Имя                | Тип        | Описание                                         | Значение по умолчанию
--------------------|------------|--------------------------------------------------|------------------------
`$uri`              | bool       | URI для выполнения                               | `TRUE` (будет использован текущий URI)
`$cache`            | HTTP_Cache | Объект для HTTP-кэширования запроса              | `NULL` (не использовать)
`$injected_routes`  | array      | Массив маршрутов, которые допустимо использовать | `array()` (будут использоваться все добавленные маршруты)

Создание запроса выполняется в несколько этапов:

 * Поиск подходящего [маршрута](basic/routing)
 * Создание `Request`-клиента. Это что-то типа драйвера, который отвечает за выполнение определенного типа запросов.
    В **Kohana** существуют [внутренние](basic/request/internal) и [внешние](basic/request/external) запросы.

## Стартовый запрос {#initial}

Kohana поддерживает [HMVC](basic/hmvc), т.е. мы можем одновременно иметь несколько объектов `Request`. Однако один из них
 всегда будет отличаться от остальных - тот, что был создан первым.

Стартовый запрос хранится в виде свойства `Request::$initial` (публичное свойство), также можно к нему обратиться через
 метод [Request::initial]. Если стартовый запрос еще не создан (небольшой промежуток времени, пока система не вызвала [Request::factory]
 в файле `index.php`), то свойство содержит `NULL`.

Чтобы определить, является ли объект `Request` стартовым, достаточно вызвать метод [Request::is_initial]. По сути он просто
 сравнивает текущий объект с `Request::$initial`.

Главное отличие стартового запроса в том, что он хранит в себе некоторые данные, полученные от пользователя:

 Свойство              | Тип     | Описание                                 | По умолчанию
-----------------------|---------|------------------------------------------|-----------------
 $_protocol            | string  | Протокол HTTP                            | HTTP::$protocol ('HTTP/1.1')
 $_secure              | boolean | Использовать безопасную версию протокола | FALSE
 $_method              | string  | HTTP-метод                               | HTTP_Request::GET ('GET')
 $_referrer            | string  | Источник перехода                        | NULL
 $_requested_with      | string  | Заголовок x-requested-with               | NULL
 Request::$client_ip   | string  | IP-адрес клиента                         | '0.0.0.0'
 $_body                | string  | Тело запроса (кроме GET-запросов)        | NULL
 Request::$user_agent  | string  | Строка с описанием браузера              | ''

[!!] Обратите внимание на свойство `$body`! В нем сохраняется содержимое тела запроса. Если Вы планируете работать с PUT-запросами,
 то именно здесь будут все необходимые данные. Используйте `$this->request->body()` для их извлечения в "сыром виде".

Эти данные могут быть полезны при работе любого из [подзапросов](basic/hmvc). Получить статические значения можно напрямую
 (т.к. они в `public`-доступе), а локальные свойства доступны через геттеры, например:

    // получить адрес реферера
    $referrer = Request::initial()->referrer();
    // актуально для PUT/POST запросов
    $put_data = parse_str(Request::initial()->body());

## Поиск маршрута {#routing}

Получив от системы URI, необходимо определить, какой контроллер надо создать и какой экшен выполнить. Связующим звеном для
 этих целей служат маршруты. К моменту создания запроса в приложении должен быть зарегистрирован хотя бы один маршрут, это
 очевидно. Ведь иначе мы не сможем выполнить поставленную задачу.

Итак, в системе есть несколько маршрутов (их всегда можно получить с помощью вызова [Route::all]). Далее все эти маршруты
 в цикле проверяются на соответствие переданному URI. Для этого служит метод [Route::matches]. Если URI подходит под [регулярное
 выражение](intro/routing), то маршрут вычисляет и возвращает параметры для данного адреса.

[!!] Не забывайте, что порядок, в котором маршруты были зарегистрированы в системе, имеет [большое значение](basic/routing#multiple) !

Если маршрут не подходит, то запрос переходит к обработке следующего. Если ни один из маршрутов не подходит, то запрос останется
 без выбранного маршрута. Для сравнения, в версиях **3.0** и **3.1** сразу же выбрасывалось исключение [HTTP_Exception_404].

[!!] Если для тестирования конкретного маршрута следует использовать [Route::matches], то для проверки системы в целом
 используйте [Request::process_uri]. Он вернет либо массив данных (маршрут и его параметры), либо `NULL`.

## Запуск контроллера {#execute}

Создание запроса, заполнение его начальными данными, а также поиск маршрута - это все происходит внутри вызова `Request::factory()`.
 Собственно выполнение запроса происходит с помощью метода [Request::execute]. И основная его часть - это работа с [контроллером](intro/mvc/controller).

Имя контроллера определяется из соответствующего параметра маршрута (`controller`). Аналогично определяется директория
 (`directory`) и экшен (`action`). `controller` и `directory` формируют имя класса контроллера, а экшен - имя метода контроллера.

Алгоритм запуска контроллера:

 * Определяется имя класса контроллера. В общем виде это `Controller_<directory>_<controller>`. Если класс с таким именем
 не найден, то генерируется исключение [HTTP_Exception_404] (Not Found). Также, если класс существует, но является абстрактным
 (`abstract class`), бросается исключение [Kohana_Exception] с соответствующим текстом.
 * Выполняется метод `before()`. Этот метод существует в каждом классе-потомке `Controller`, он предназначен для выполнения
  различных проверок, инициализации свойств контроллера и т.д.
 * Определяется имя метода контроллера: `action_<action>`. Если в контроллере нет такого метода, будет сгенерировано исключение
 `HTTP_Exception_404`.
 * После отработки экшена выполняется метод `after`.

Метод [Request::execute] возвращает объект [Response](basic/response), который содержит результат работы запроса (заголовки
 и тело ответа). Также этот объект становится доступным через метод [Request::response].

## HMVC {#hmvc}

**Kohana** поддерживает [HMVC](http://ru.wikipedia.org/wiki/HMVC). Это означает, что в системе одновременно могут существовать
 несколько запросов. Очевидно, что в какой-то конкретный момент времени выполняться может только один из них. Такой запрос
 называется текущим, и может быть получен с помощью метода `Request::current()`.

Каждый раз, когда выполняется запрос (т.е. вызван метод [Request::execute()]), выполняется проверка на наличие текущего запроса.
 Если он существует, то данный запрос должен запомнить его, вытеснить на время выполнения, и затем вернуть старый запрос
 на роль текущего.

[!!] Текущий запрос (`Request::current()`) не всегда совпадает со стартовым (`Request::initial()`). Об этом стоит помнить.

## Типы запросов {#types}

В **Kohana** существует возможность использовать объекты `Request` не только для обращения к адресам внутри текущего сайта,
 но и к внешним источникам. Таким образом, можно выделить [внутренние](basic/request/internal) (internal) и [внешние](basic/request/external)
 (external) запросы. Если при создании запроса передан полный URL (с протоколом, например `http://`), то такой запрос будет
 обрабатываться как внешний, даже если он ведет на текущий сайт:

    Request::factory('http://yandex.ru')->execute(); // внешний
    Request::factory('/foo/bar')->execute(); // внутренний
    Request::factory('http://localhost/foo/bar'); // внешний

Сам по себе объект `Request` не делит запросы на внешние и внутренние. Различие в объекте `Request_Client`, который по сути
 является драйвером и отвечает за транспорт запроса от источника к адресату. Данный объект доступен из `Request` с
 помощью метода [Request::client].

Подробнее работа с каждым из видом запросов рассматривается в соответствующих подразделах учебника. Ниже будут описаны
 универсальные методы, общие для всех запросов.

## Установка параметров {#setparams}

HMVC в **Kohana** позволяет полностью имитировать обычное обращение к странице через браузер. Можно устанавливать свои
 HTTP-заголовки, тело запроса (актуально для `PUT`-запросов), куки, GET и POST-данные. Например:

	Request::factory('http://www.google.com/search')
		->query(array(
			'ie' => 'utf-8',
			'oe' => 'utf-8',
		))
		->query('q', 'kohana101')
		->headers('Accept-Language', 'ru-ru,ru;q=0.8,en-us;q=0.5,en;q=0.3')
		->headers('User-Agent', 'Kohana101 example')
		->method(HTTP_Request::POST)
		->execute();

Метод [Request::query] позволяет устанавливать GET-параметры, причем можно передавать как отдельные пары ключ-значение, так
 и целый массив. Аналогично работает метод [Request::post], который устанавливает POST-данные.

[!!] Важное замечание! Передача массива значений полностью затрет все предыдущие переменные, поэтому я сперва вызвал `query()`
 с массивом кодировок, и только потом передал поисковую фразу.

[!!] Помимо метода `query()`, параметры GET-запроса можно передать и через URI/URL. Т.е. `Request::factory('welcome/?foo=bar')`
 Однако данные, переданные явно через метод `query()`, будут иметь приоритет.

Далее мы устанавливали HTTP-заголовки. Метод [Request::headers] принимает на входе либо два аргумента (имя заголовка и его
 значение), либо массив заголовков в виде пар ключ-значение. Передача массива удалит все предыдущие установленные заголовки.

Из названия метода понятно, что [Request::method] устанавливает HTTP-метод запроса. Используйте **CRUD**-константы класса `HTTP_Request`:
`GET`, `POST`, `PUT`, `DELETE`. По умолчанию, конечно, `GET`.

## Получение параметров {#getparams}

При обработке запроса может потребоваться получить доступ к тем или иным его параметрам. В **Kohana** часто практикуется
 совмещение сеттеров и геттеров в одном методе:

	$get = Request::current()->query();                     // получить все GET-данные
	$key = Request::current()->post('key');                 // получить POST-параметр key
	$headers = Request::current()->headers();               // все заголовки
	if (Request::current()->method() == HTTP_Request::POST) // проверка на POST-запрос